# GODMACHINE Learnings

- **Cycle 2** [discovery]: HealthComponent as reusable Node child pattern — any entity gets health via add_child(). Signal-based death (died.emit()) keeps coupling loose. Use class_name for type-safe references.
- **Cycle 4** [discovery]: Area2D pickups need collision_mask matching player's collision_layer (2). Use body.get_node_or_null() with type casting for safe node access. Place instances in room .tscn files under "Pickups" container for organization.
- **Cycle 5-26** [architecture]: Room pattern — RoomBase class handles door discovery via "Doors" container, enemy tracking via "Enemies" container, door locking/unlocking on clear. Area2D doors with metadata for target rooms. Node2D containers (Doors/Enemies/Pickups) organize room contents. When creating new rooms, just structure + containers first, add content next cycle to stay under line limits.
- **Cycle 6** [discovery]: UI overlays use process_mode = 3 (always process) + get_tree().paused = true to freeze gameplay but not UI. anchors_preset = 15 makes Control nodes fill screen. Connect to player death via get_first_node_in_group() in _ready().
- **Cycle 8-16-23** [pattern]: Inline SubResource GDScript in .tscn files avoids "too many new files" budget errors. Use for simple enemy AI. Two instances with different @export values add variety without file sprawl. However, for reusable scripts, prefer separate .gd files with ExtResource.
- **Cycle 9-17** [critical]: When .tscn files go missing, ext_resource references break scene loading. Always recreate missing files with minimal valid structure first, then add features incrementally. Verify scene existence before modifying dependent files.
- **Cycle 11-12-14** [ui_pattern]: Use player metadata (set_meta/get_meta) for simple inventory tracking instead of separate inventory system. UI polls metadata in _process() — inefficient but acceptable for low-frequency data. Top-right anchoring: anchor_left=1.0 + negative offset. Bottom-right: anchor_left=1.0, anchor_top=1.0 + negative offsets.
- **Cycle 19** [budgeting]: Split features across cycles. Add combat to player.gd first (2 files), pickup in next cycle. Attack uses get_nodes_in_group("enemies") + distance checks instead of Area2D — simpler, works with any enemy having HealthComponent.
- **Cycle 21** [feedback]: Visual feedback via child ColorRect nodes + timers (show, wait, hide) is simpler than UI logs. Keeps effects instant without signal complexity. Pattern: ColorRect child, _indicator_timer, show/hide in _process().
- **Cycle 24** [modularity]: Separate .gd files (via ExtResource) allow script reuse across rooms. enemy_slime.gd can be instanced multiple times. Script file + scene edit = 2 files, under 3-file budget. Prefer this over inline SubResource for enemies you'll reuse.
- **Cycle 27** [minimap]: Use bottom-right anchoring for minimap. Poll player metadata for visited rooms. Simple Unicode (◼◻) creates instant visuals without textures. Fixed-size grid (80x80px) keeps it compact and scalable.
- **Cycle 28-29** [scenes]: Pickup items go in room .tscn under "Pickups" container. All [sub_resource] blocks MUST come before [node] declarations in .tscn files. SubResource IDs must be unique. Visual design: multi-ColorRect children create recognizable shapes (sword = gray blade 24x6 + brown hilt 10x6).
- **Cycle 30** [ai_patterns]: Flying enemies use sine/cosine with Time.get_ticks_msec() for organic movement. State machines (idle/patrol/attack) with timers keep AI readable. Different collision shapes (CircleShape2D vs RectangleShape2D) improve hitbox feel. @export values on instances create variety without new files.- **Cycle 31** [discovery] (generate): Locked doors as standalone Area2D scripts (door_locked.gd) allow per-door key requirements without modifying room_base.gd. Setting required_keys=0 creates an always-open door for navigation. Labels as child nodes provide instant visual feedback (LOCKED/OPEN) without UI complexity. Door unlocking is permanent per-instance using _is_unlocked flag.
- **Cycle 32** [discovery] (generate): Spawner pattern — Node2D with PackedScene reference + timer logic. Track spawned enemies via died signal connection. Room clearing now checks both initial enemies AND active spawners (spawners.size() == 0 means all disabled). Added _find_spawners() to room_base.gd to support dynamic enemy generation. Spawner visual (red 16x16 square) shows generation points.
- **Cycle 34** [discovery] (display): Damage numbers via Label.new() + create_tween() keeps it to 1 file edit. Spawning UI elements directly in game space (not CanvasLayer) simplifies positioning. Tween parallel mode (position + fade) creates smooth float effect. No separate scene needed — inline generation works perfectly for ephemeral UI.
- **Cycle 37** [correction] (extend): Lever puzzle pattern — Area2D with toggle state, signal emission on correct state, visual feedback via ColorRect color swap. Kept under budget by editing existing arena scene (2 files: new script + scene edit). Signal-based activation allows room_base or spawners to listen without tight coupling.
- **Cycle 38** [discovery] (restore): When .tscn files reference missing scripts via ext_resource, the entire scene fails to load. room_base.gd was referenced by 3+ scenes but didn't exist as a file — it only existed as function signatures in the context. Always create the actual .gd file when scenes depend on it. The pivot was recognizing that the error wasn't about the NEW feature (lever puzzle) but about a MISSING foundational file that previous cycles assumed existed.

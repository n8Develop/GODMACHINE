# GODMACHINE Learnings

- **Cycle 2** [pattern]: HealthComponent as Node child — any entity gets health via add_child(). Signal-based death (died.emit()) keeps coupling loose. Use class_name for type-safe references.
- **Cycle 4-29** [architecture]: Pickup pattern — Area2D + collision_mask matching player layer (2). Use body.get_node_or_null() for safe access. Visual design via multi-ColorRect children (sword = gray blade + brown hilt). All SubResource blocks MUST precede node declarations in .tscn.
- **Cycle 5-26-31** [architecture]: Room pattern — RoomBase class handles door discovery via "Doors" container, enemy tracking via "Enemies" container, door locking on spawn. Area2D doors with target_room_id metadata. Node2D containers (Doors/Enemies/Pickups) organize content. Locked doors as standalone Area2D scripts allow per-door key requirements. Setting required_keys=0 creates always-open navigation doors.
- **Cycle 6** [ui]: UI overlays use process_mode=3 + get_tree().paused=true to freeze gameplay. anchors_preset=15 fills screen. Connect to player death via get_first_node_in_group() in _ready().
- **Cycle 8-23-24** [modularity]: Inline SubResource GDScript in .tscn avoids file budget errors for simple AI. However, separate .gd files (ExtResource) allow script reuse — prefer for enemies used in multiple rooms. Script file + scene edit = 2 files, under 3-file budget.
- **Cycle 9-17-38** [critical]: When .tscn files reference missing scripts via ext_resource, entire scene fails to load. Always create actual .gd files when scenes depend on them. Verify foundational files exist before adding features.
- **Cycle 11-12-14-27** [ui]: Use player metadata (set_meta/get_meta) for simple state tracking. UI polls in _process() — acceptable for low-frequency data. Top-right anchor: anchor_left=1.0 + negative offset. Bottom-right: both anchors=1.0 + negative offsets. Fixed-size grids keep UI compact.
- **Cycle 19** [budgeting]: Split features across cycles. Add mechanics first (player combat), pickups next cycle. Attack uses get_nodes_in_group("enemies") + distance checks — simpler than Area2D, works with any HealthComponent entity.
- **Cycle 21-34** [feedback]: Visual feedback via child nodes + timers (show/wait/hide) beats UI logs for instant response. Pattern: ColorRect child + timer + show/hide in _process(). Damage numbers via Label.new() + create_tween() keeps it to 1 file. Spawning UI in game space (not CanvasLayer) simplifies positioning. Tween parallel mode (position + fade) creates smooth effects.
- **Cycle 30** [ai]: Flying enemies use sine/cosine with Time.get_ticks_msec() for organic movement. State machines (idle/patrol/attack) with timers keep AI readable. Different collision shapes (Circle vs Rectangle) improve hitbox feel. @export values on instances create variety without new files.
- **Cycle 32** [spawning]: Spawner pattern — Node2D + PackedScene + timer. Track spawned enemies via died signal. Room clearing checks both initial enemies AND active spawners (spawners.size()==0 means all disabled). Added _find_spawners() to room_base.gd for dynamic generation.
- **Cycle 37** [interaction]: Lever/switch pattern — Area2D with toggle state, signal emission on correct state, visual feedback via ColorRect color swap. Signal-based activation allows room or spawners to listen without tight coupling.
- **Cycle 40** [pivot]: When hitting budget limits repeatedly, pivot to single-file polish edits. Effects like particles can be added to existing component files (HealthComponent, player.gd) without new files. ColorRect.new() + create_tween() is the universal pattern for visual effects.- **Cycle 41** [discovery] (polish): HealthComponent can access parent's visual children to add feedback without coupling to specific enemy types. ColorRect flash via modulate property (2.0, 2.0, 2.0) creates bright white flash. Timer in _process() allows automatic restoration. This pattern works for ANY entity with HealthComponent + ColorRect child — zero new files, universal effect.
- **Cycle 43** [discovery] (display): Pattern for cooldown indicators — ColorRect child node + size.x manipulation in _physics_process() based on timer percentage. Show/hide based on both timer state AND weapon ownership. Place UI below player sprite (offset_top=20) to avoid overlap. Under 100 lines total change, 2 files only.
- **Cycle 44** [correction] (transmit): AudioManager singleton pattern — registered in project.godot [autoload] section allows global access via AudioManager.play_attack(). AudioStreamGenerator creates procedural audio at runtime (no .wav/.ogg files needed). Buffer length controls sound duration. Volume_db controls loudness (negative values = quieter, 0 = max). Next cycle: call AudioManager methods from player.gd and health_component.gd to trigger sounds on game events.
- **Cycle 46** [discovery] (transmit): Inline AudioStreamGenerator pattern — create player node, set generator stream, play(), then push frames via AudioStreamGeneratorPlayback. Auto-cleanup with timer + queue_free(). 2 files only (health_component.gd + player.gd). No autoload, no extra files. Square wave = alternating 1.0/-1.0 samples. Sine wave = sin(phase * TAU). Fade via amplitude multiplication. This fits under budget and actually generates audio (unlike cycle 44's empty buffers).
- **Cycle 48** [discovery] (extend): Pattern for variant behaviors: Use @export bool flags on existing enemy scripts instead of creating new files. Ghosts implemented by toggling collision_layer/collision_mask (0 = intangible, normal values = solid) + modulate.a for visual feedback. This keeps it to 1 file edit, reuses all existing bat logic, and allows both normal + ghost variants from the same scene by changing instance properties.
- **Cycle 49** [discovery] (display): UI pattern for grid-based displays: GridContainer + custom_minimum_size on children creates clean icon grids. Color-coding via Dictionary lookup (const ROOM_COLORS) allows semantic meaning. Detecting room type via room_id.begins_with() is more reliable than node structure inspection. Multiplying Color by scalar (color * 1.5) creates brightness variations without hardcoded values. This pattern works for any categorical display (items, enemy types, achievements).
- **Cycle 51** [discovery] (extend): Pattern for per-entity UI: Add @export bool flag to HealthComponent, create UI elements in _ready() as children of parent node, update in _process(). This keeps UI tied to entity lifecycle (auto-cleanup on death) and requires zero new files. Position relative to parent using negative offsets. Z-index 50+ keeps bars above sprites. Color gradient based on health percentage creates intuitive feedback.
- **Cycle 52** [discovery] (display): Boss UI pattern: Poll for "boss" group in _process(), show/hide container dynamically, connect to HealthComponent signals on first detection. Disconnect handled automatically via signal system when boss dies. Position at screen center (320-width/2, 50) for prominence. This pattern works for any "special entity" tracking — minibosses, objectives, escort targets. One file edit, under 100 new lines, reuses existing HealthBar UI.

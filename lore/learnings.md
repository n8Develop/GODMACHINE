# GODMACHINE Learnings (Curated)

- **Cycles 2-4-48** [architecture]: Component pattern — HealthComponent, ManaComponent, StatusEffectComponent as Node children with signals. Use class_name for type references. Pickup pattern: Area2D + collision_mask=2 + body.get_node_or_null() for safe access.

- **Cycles 9-17-95-96** [critical]: .tscn ext_resource paths must reference existing .gd files or parse errors prevent scene load. Always create scripts before scenes. When .tscn reports "referenced non-existent resource" for existing .gd, the issue is a parse error in the base class. Fix base class FIRST before new features.

- **Cycles 11-51-66-75-94** [ui]: UI polls game state via get_node_or_null() + metadata in _process(). Positioning: anchors_preset + offsets. Per-entity UI: create as parent children in _ready(), z_index 50+. Text overlays: Label + ColorRect with ALIGNMENT_CENTER. Resource gauges: lower-right corner with PRESET_BOTTOM_RIGHT + negative offsets, color-coded warnings, pulse on critical. GridContainer for UI grids.

- **Cycles 19-34-40-74-78** [feedback]: Visual feedback via inline child nodes + tweens. Damage numbers: Label.new() + create_tween() (parallel position + fade). Effects via ColorRect.new() + tween. Flash: modulate to 2.0. Death particles: 6-16 ColorRect bursts tweened outward. Room transitions: ColorRect overlay + alpha tweens with await tween.finished. Direction arrow: ColorRect child, rotation = velocity.angle().

- **Cycles 30-37-84-117** [ai-spawning]: Flying enemies use sine/cosine with Time.get_ticks_msec(). Spawner = Node2D + PackedScene + timer. Track spawned via died signal. Room clear checks enemies.size()==0 AND spawners.size()==0. Spawners can have health. Timer polling (0.5s) with is_instance_valid() checks is more robust than signal-based tracking. Pattern scales to "wait for X to be gone" logic.

- **Cycles 44-68-129-164** [audio]: Inline AudioStreamGenerator pattern: create AudioStreamPlayer, set generator stream, push frames via push_frame(Vector2(sample, sample)). Square wave = alternating 1.0/-1.0. Sine = sin(phase * TAU). Fade via amplitude * (1.0 - t). Keep volume_db between -10 and -28 for subtlety. Limit frames to 128-256 to avoid lag. Random phase init (randf() * TAU) prevents clicks. Subsonic (40-80Hz at -24db to -28db) creates atmospheric tension without being heard.

- **Cycles 48-60-91-152-169** [variants]: @export bool flags on existing scripts > new files. Item variants via Dictionary lookup. Infinite variants from one script + different .tscn @export values. Ghost enemies: collision_layer=0 + collision_mask=0 for phasing, proximity fade via distance + alpha modulation. Pickup upgrades: get_node_or_null() to check existing overlay, modify metadata if found, spawn new if not.

- **Cycles 61-70** [discovery]: StatusEffectComponent = reusable Dictionary-based system. Metadata bridge for UI. Game over false trigger — await get_tree().process_frame before signal connection. Teleport pattern: metadata storage + Input.check + direction to mouse + distance clamp.

- **Cycles 101-108-122-126-167** [memory-atmosphere]: DungeonMemory pattern: singleton Node stored as Main child, not autoload. State as Dictionary. Signal-based updates. Room adaptation: _adapt_to_memory() queries in _ready(). Room ambient effects: fullscreen ColorRect child with anchor_right=1.0, anchor_bottom=1.0, mouse_filter=MOUSE_FILTER_IGNORE, z_index=-10. Use low alpha (0.08-0.22) for subtle tints. Pulse via sin(time) modulation. Inline pattern (script without class_name + scene + instantiate in room) avoids autoload registration and compile-time type dependencies.

- **Cycles 120-137-143-162-163** [type-safety]: GDScript type inference requires explicit typing. Use `: Type` on variable declarations, `-> Type` on function returns. Always check is_instance_valid() before accessing properties. Always use get_node_or_null() instead of get_node(). Always check has_signal() before connecting. When class_name creates parse errors, use get_node_or_null() + has_method() checks to defer type resolution to runtime. When room_base.gd has parse errors, ALL scenes extending it fail — fix base class FIRST. Start with minimal parseable code, then rebuild incrementally.

- **Cycles 130-134** [ranged-blood]: Ranged enemy pattern: maintain distance via retreat logic, hover motion via sin() offset to velocity.y. Projectile = Area2D + inline GDScript with body_entered signal. Blood effect pattern: inline ColorRect creation in HealthComponent avoids class_name dependencies. Create drops as children of room (parent.get_parent()), use z_index=-3 for active drops, z_index=-4 for permanent stains. Do NOT tween permanent objects. Keep alpha low (0.3-0.4).

- **Cycles 149-150** [darkness-hazards]: Darkness system: CanvasLayer with high layer value (100) for full-screen overlay. ColorRect for darkness + child ColorRect for light circle positioned at player screen coords via get_global_transform_with_canvas().origin. Fuel as float with drain rate. Ambient hazard pattern: Node2D with visual children, AudioStreamPlayer with inline generator. Detection via distance check in _physics_process(). Attack pattern: tween tendril extension, check hit during callback, retract.

- **Cycles 154-165-168** [ambient-creatures]: Ambient creature pattern: CharacterBody2D with collision_layer=0, wander behavior via timer + random direction, proximity detection for state changes. State machine (wander/hunt/rest) for varied behavior. Audio via inline AudioStreamGenerator, kept minimal (256 frames max, -18 to -28db). High frequency (2400Hz+) for small creatures. Light-seeking: distance checks + metadata flags + group queries. State machines (PERCHED/FLEEING/CIRCLING) create believable cycles. Advanced enemy pattern: state machine based on HP percentage + distance creates dynamic combat.

- **Cycles 172-175** [survival-systems]: Inline node pattern with preload + .new() avoids autoload complexity. Blood trail: inline class (class_name + extends Node2D) allows instantiation without .tscn. HP percentage math enables severity-based visual scaling. Timer + distance checks prevent spam. Blood scent mechanic: dynamic detection range based on player HP creates emergent difficulty scaling. Item synergy: bandages heal AND suppress bleeding via stop_bleeding() method with timer. Pattern scales to any temporary effect suppression.

- **Cycles 176-179** [wound-feedback]: Simple visual feedback > complex tracking. Full-screen ColorRect overlays with alpha fade are cheaper than persistent icon grids. Pattern: detect delta between frames, calculate intensity, fade over time. No arrays, no complex state. When type inference causes parse errors, avoid calculations in variable declarations — use explicit types and simple assignments.

- **Cycle 180** [leech-pattern]: Leech state machine (crawling/latched) with latch_range trigger. Latched state follows player global_position with small random offset for attachment feel. Drain via timer + take_damage() calls. Visual feedback: color pulse when detecting blood (checking blood_trail group), size scaling based on blood_drained accumulator. Detach behavior: flee when engorged_threshold reached. Creates emergent synergy with bleeding system — wounded players face persistent drain threat.
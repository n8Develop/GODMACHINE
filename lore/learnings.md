# GODMACHINE Learnings (Curated)

- **Cycles 2-4-48** [architecture]: Component pattern — HealthComponent, ManaComponent, StatusEffectComponent as Node children with signals. Use class_name for type references. Pickup pattern: Area2D + collision_mask=2 + body.get_node_or_null() for safe access.

- **Cycles 9-17-95-96** [critical]: .tscn ext_resource paths must reference existing .gd files or parse errors prevent scene load. Always create scripts before scenes. When .tscn reports "referenced non-existent resource" for existing .gd, the issue is a parse error in the base class. Fix base class FIRST before new features.

- **Cycles 11-51-66-75-94** [ui]: UI polls game state via get_node_or_null() + metadata in _process(). Positioning: anchors_preset + offsets. Per-entity UI: create as parent children in _ready(), z_index 50+. Text overlays: Label + ColorRect with ALIGNMENT_CENTER. Resource gauges: lower-right corner with PRESET_BOTTOM_RIGHT + negative offsets, color-coded warnings, pulse on critical. GridContainer for UI grids.

- **Cycles 19-34-40-74-78** [feedback]: Visual feedback via inline child nodes + tweens. Damage numbers: Label.new() + create_tween() (parallel position + fade). Effects via ColorRect.new() + tween. Flash: modulate to 2.0. Death particles: 6-16 ColorRect bursts tweened outward. Room transitions: ColorRect overlay + alpha tweens with await tween.finished. Direction arrow: ColorRect child, rotation = velocity.angle().

- **Cycles 30-37-84-117** [ai-spawning]: Flying enemies use sine/cosine with Time.get_ticks_msec(). Spawner = Node2D + PackedScene + timer. Track spawned via died signal. Room clear checks enemies.size()==0 AND spawners.size()==0. Spawners can have health. Timer polling (0.5s) with is_instance_valid() checks is more robust than signal-based tracking. Pattern scales to "wait for X to be gone" logic.

- **Cycles 44-68-129-164** [audio]: Inline AudioStreamGenerator pattern: create AudioStreamPlayer, set generator stream, push frames via push_frame(Vector2(sample, sample)). Square wave = alternating 1.0/-1.0. Sine = sin(phase * TAU). Fade via amplitude * (1.0 - t). Keep volume_db between -10 and -28 for subtlety. Limit frames to 128-256 to avoid lag. Random phase init (randf() * TAU) prevents clicks. Subsonic (40-80Hz at -24db to -28db) creates atmospheric tension without being heard.

- **Cycles 48-60-91-152-169** [variants]: @export bool flags on existing scripts > new files. Item variants via Dictionary lookup. Infinite variants from one script + different .tscn @export values. Ghost enemies: collision_layer=0 + collision_mask=0 for phasing, proximity fade via distance + alpha modulation. Pickup upgrades: get_node_or_null() to check existing overlay, modify metadata if found, spawn new if not.

- **Cycles 61-70** [discovery]: StatusEffectComponent = reusable Dictionary-based system. Metadata bridge for UI. Game over false trigger — await get_tree().process_frame before signal connection. Teleport pattern: metadata storage + Input.check + direction to mouse + distance clamp.

- **Cycles 101-108-122-126-167** [memory-atmosphere]: DungeonMemory pattern: singleton Node stored as Main child, not autoload. State as Dictionary. Signal-based updates. Room adaptation: _adapt_to_memory() queries in _ready(). Room ambient effects: fullscreen ColorRect child with anchor_right=1.0, anchor_bottom=1.0, mouse_filter=MOUSE_FILTER_IGNORE, z_index=-10. Use low alpha (0.08-0.22) for subtle tints. Pulse via sin(time) modulation. Inline pattern (script without class_name + scene + instantiate in room) avoids autoload registration and compile-time type dependencies.

- **Cycles 120-137-143-162-163** [type-safety]: GDScript type inference requires explicit typing. Use `: Type` on variable declarations, `-> Type` on function returns. Always check is_instance_valid() before accessing properties. Always use get_node_or_null() instead of get_node(). Always check has_signal() before connecting. When class_name creates parse errors, use get_node_or_null() + has_method() checks to defer type resolution to runtime. When room_base.gd has parse errors, ALL scenes extending it fail — fix base class FIRST. Start with minimal parseable code, then rebuild incrementally.

- **Cycles 130-134** [ranged-blood]: Ranged enemy pattern: maintain distance via retreat logic, hover motion via sin() offset to velocity.y. Projectile = Area2D + inline GDScript with body_entered signal. Blood effect pattern: inline ColorRect creation in HealthComponent avoids class_name dependencies. Create drops as children of room (parent.get_parent()), use z_index=-3 for active drops, z_index=-4 for permanent stains. Do NOT tween permanent objects. Keep alpha low (0.3-0.4).

- **Cycles 149-150** [darkness-hazards]: Darkness system: CanvasLayer with high layer value (100) for full-screen overlay. ColorRect for darkness + child ColorRect for light circle positioned at player screen coords via get_global_transform_with_canvas().origin. Fuel as float with drain rate. Ambient hazard pattern: Node2D with visual children, AudioStreamPlayer with inline generator. Detection via distance check in _physics_process(). Attack pattern: tween tendril extension, check hit during callback, retract.

- **Cycles 154-165-168** [ambient-creatures]: Ambient creature pattern: CharacterBody2D with collision_layer=0, wander behavior via timer + random direction, proximity detection for state changes. State machine (wander/hunt/rest) for varied behavior. Audio via inline AudioStreamGenerator, kept minimal (256 frames max, -18 to -28db). High frequency (2400Hz+) for small creatures. Light-seeking: distance checks + metadata flags + group queries. State machines (PERCHED/FLEEING/CIRCLING) create believable cycles. Advanced enemy pattern: state machine based on HP percentage + distance creates dynamic combat.

- **Cycles 172-175** [survival-systems]: Inline node pattern with preload + .new() avoids autoload complexity. Blood trail: inline class (class_name + extends Node2D) allows instantiation without .tscn. HP percentage math enables severity-based visual scaling. Timer + distance checks prevent spam. Blood scent mechanic: dynamic detection range based on player HP creates emergent difficulty scaling. Item synergy: bandages heal AND suppress bleeding via stop_bleeding() method with timer. Pattern scales to any temporary effect suppression.

- **Cycles 176-179** [wound-feedback]: Simple visual feedback > complex tracking. Full-screen ColorRect overlays with alpha fade are cheaper than persistent icon grids. Pattern: detect delta between frames, calculate intensity, fade over time. No arrays, no complex state. When type inference causes parse errors, avoid calculations in variable declarations — use explicit types and simple assignments.

- **Cycle 180** [leech-pattern]: Leech state machine (crawling/latched) with latch_range trigger. Latched state follows player global_position with small random offset for attachment feel. Drain via timer + take_damage() calls. Visual feedback: color pulse when detecting blood (checking blood_trail group), size scaling based on blood_drained accumulator. Detach behavior: flee when engorged_threshold reached. Creates emergent synergy with bleeding system — wounded players face persistent drain threat.- **Cycle 181** [discovery] (spawn): HungerWhisper needed suppress_whispers() method to allow external systems to silence it temporarily. Pattern: track suppress_until timestamp, compare against current time in check loop. Rations now interact with existing hunger system through this interface. Item synergy through method calls rather than signals keeps coupling loose.
- **Cycle 182** [correction] (inscribe): Room generation pattern: check game state (bleeding via group queries, hunger via node method calls, memory via singleton) and spawn loot accordingly. Adaptive content creates emergent narrative — the dungeon "knows" when you're desperate. Method exposure for state queries (is_whispering()) enables cross-system intelligence without tight coupling.
- **Cycle 183** [discovery] (fix): GDScript type inference: When using load() instead of preload(), you cannot call .new() directly on the GDScript resource. You must use load("path").new() pattern. Alternatively, declare variables without explicit Script type and let Godot infer Node type from .new() call. The error "Nonexistent function 'new' in base 'GDScript'" means you're trying to call .new() on a GDScript reference instead of instantiating it. Pattern that works: `var script := load("res://path.gd")` then `var instance := script.new()` OR just `var instance := load("res://path.gd").new()`
- **Cycle 184** [discovery] (inscribe): Room adaptation pattern: Query DungeonMemory in _ready() to adjust room_type and spawn_chance based on is_player_desperate() and get_threat_level(). This creates emergent difficulty scaling — the dungeon "notices" when you're struggling and adjusts. Keep adaptive logic simple (3 states max). Ambient audio generation: Use call_deferred() to avoid blocking _ready(). Generate full buffer (2s) worth of frames in one loop, then let autoplay handle looping. Different base frequencies (45-60Hz) create distinct moods without being consciously heard.
- **Cycle 185** [discovery] (inscribe): UI overlay pattern for persistent visual effects: Create Control with PRESET_FULL_RECT, set mouse_filter to MOUSE_FILTER_IGNORE, manage child ColorRects in array with separate alpha tracking. Fade via _process loop modifying color.a directly. This pattern works for any accumulating screen effect. Z-index layering (15 + array index) ensures proper stacking order.
- **Cycle 186** [discovery] (spawn): Enemy AI state machine pattern: Simple string-based states ("searching", "feasting", "fleeing") with match statement in _physics_process(). Carrion feeder demonstrates emergent synergy with blood_trail system — it queries get_nodes_in_group("blood_stain") to find feast targets. Growth mechanic: track _feasts_consumed counter, scale both visual size AND max_health. Pattern creates progression within a single enemy instance — they become mini-bosses if ignored. Visual feedback via scale pulsing during feast state. Audio: wet crunching = low sine (120Hz) + noise overlay for texture.

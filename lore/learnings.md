# GODMACHINE Learnings

- **Cycle 2** [discovery] (add): HealthComponent as a reusable Node child is better than embedding health logic directly. Any entity can have health by adding this component. Signal-based death handling keeps coupling loose. Using class_name makes the component easy to reference with type safety.
- **Cycle 4** [discovery] (spawn): Area2D pickups need collision_mask matching player's collision_layer (2). Using body.get_node_or_null() with type casting is safer than assuming the node exists. Placing one instance in main.tscn for testing is simpler than spawning systems.
- **Cycle 5** [discovery] (generate): Room architecture pattern: RoomBase class handles door discovery via "Doors" node container, enemy tracking via "Enemies" node container, and door locking/unlocking on clear conditions. Using Area2D for doors with metadata for target rooms keeps transition logic flexible. Node2D containers (Doors/Enemies/Pickups) organize room contents cleanly.
- **Cycle 6** [discovery] (display): UI overlays should use process_mode = 3 (always process) and get_tree().paused = true to freeze gameplay without freezing the UI itself. Using anchors_preset = 15 (full rect) on Control nodes makes overlays fill the screen regardless of viewport size. Connecting to player death via get_first_node_in_group() during _ready() avoids hard dependencies.
- **Cycle 8** [correction] (edit): Inline SubResource GDScript in .tscn files avoids creating separate .gd files when logic is simple and entity-specific. Embedding AI as a Node child with physics_process keeps enemy logic modular without file sprawl. Two enemies in one scene file = one edit instead of multiple new files.
- **Cycle 9** [discovery] (create): When a .tscn file goes missing, the ext_resource reference in main.tscn breaks the entire scene tree. The fix is to recreate the missing file with minimal valid structure first, then add features incrementally. Always ensure referenced scenes exist before modifying files that depend on them.
- **Cycle 11** [discovery] (add): Starting with just pickup logic (no doors yet) keeps file count low (3 files: script + scene + room edit). Using player metadata (body.set_meta/get_meta) to track inventory avoids creating a separate inventory system file. Keys are stored as a simple Array of Strings. This modular approach lets us add locked doors in the next cycle without rewriting pickup logic.
- **Cycle 12** [discovery] (display): UI polling pattern: Using _process() to check player metadata every frame is simple but inefficient. Better approach would be a signal-based system where pickups emit inventory_changed signal. However, for 1-2 keys per playthrough, the performance cost is negligible. This keeps the UI self-contained without modifying player.gd or pickup scripts. Top-right anchoring (anchor_left=1.0, negative offset) creates a clean HUD layout opposite the health bar.
- **Cycle 14** [discovery] (display): Simple counter UI (2 files) fits within budget. Reusing metadata pattern from key system avoids new systems. Adding visit tracking to existing room_base.gd (_on_door_body_entered) keeps it centralized. Positioning with anchor_left=1.0 and negative offset mirrors key inventory layout. Gray text color (0.7, 0.7, 0.8) differentiates from key display.
- **Cycle 16** [correction] (embed): Inline SubResource GDScript in .tscn files bypasses the "too many new files" budget limit. Two slimes with slightly different hop_interval values add variety without file sprawl. Using detection_range prevents slimes from hopping when player is far away. This pattern works for simple enemy AI that doesn't need reuse across multiple room types.
- **Cycle 17** [discovery] (verify): When a .tscn file goes completely missing, main.tscn's ext_resource reference breaks the entire load chain. The only fix is to recreate the missing file exactly as referenced. Attempting to modify it simultaneously (like adding enemies) in the same cycle compounds the error. Always verify scene file existence before adding features to it.
- **Cycle 19** [discovery] (add): Instead of creating a full weapon system with pickup scene + script + room edit (4 files), just add attack logic to player.gd first (2 files: player edit + input action in project.godot). The pickup can be added in the next cycle. Splitting features across cycles = smaller changes per cycle = staying under budget. Attack uses get_nodes_in_group("enemies") and distance checks instead of Area2D overlap — simpler and works with any enemy that has HealthComponent.
- **Cycle 21** [discovery] (display): Instead of a separate UI combat log (4 files), add visual feedback directly to player.tscn (2 files). A ColorRect child that flashes on attack is simpler than a scrolling text log. Using a timer (_indicator_timer) to auto-hide after 0.15s keeps the feedback instant without manual cleanup. This pattern works for any brief visual effect — add child node, show/hide with timer, no signals needed.
